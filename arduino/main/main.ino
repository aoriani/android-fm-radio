#include <type_traits>
#include <SparkFun_Qwiic_OLED.h>
#include <res/qw_fnt_5x7.h>
#include <Adafruit_NeoPixel.h>
#include "SparkFunSi4703.h"
#include <Wire.h>
#include <math.h>

static uint8_t droidLogo[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xC0,
  0xC0, 0xE0, 0xE0, 0xF0, 0xB0, 0xB0, 0x98, 0x98, 0x9C, 0x8C,
  0x8C, 0x86, 0x86, 0x87, 0x83, 0x80, 0x80, 0x80, 0x80, 0x80,
  0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF,
  0xFF, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83,
  0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0xF3,
  0xF3, 0xF3, 0x83, 0x83, 0x83, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x01, 0x01, 0xF1, 0xF1,
  0xF9, 0xF9, 0xF1, 0xF1, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF,
  0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
  0x0F, 0xBC, 0xF0, 0xE0, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0,
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xE0,
  0xC0, 0xC0, 0xE0, 0xF0, 0xBC, 0x0F, 0x1F, 0x3F, 0x7F, 0x70,
  0x70, 0x70, 0x71, 0x73, 0x73, 0x73, 0x73, 0x71, 0x70, 0x70,
  0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70,
  0x70, 0x70, 0x70, 0x7F, 0x3F, 0x1F, 0x00, 0x00, 0xC0, 0xE0,
  0xF0, 0xF8, 0xFC, 0xFE, 0x7F, 0x3F, 0x1F, 0x1F, 0x3F, 0x7F,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x1F, 0x3F, 0x7F,
  0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC,
  0xF8, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC,
  0xF8, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

static uint8_t errorIcon[] PROGMEM =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x80, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xF0,
  0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0,
  0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0,
  0xF0, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00,
  0x60, 0xF8, 0xFE, 0xFF, 0xFF, 0xFE, 0xF8, 0x60, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xE0, 0xFE, 0x3F, 0x1F, 0x1F, 0x1F, 0x1F, 0x3F, 0xFF, 0xFF,
  0xFF, 0xCC, 0x80, 0x80, 0xC0, 0xE1, 0xF3, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xF3, 0xE1, 0xC0, 0x80, 0x80, 0xCC, 0xFF,
  0xFF, 0xFE, 0xF8, 0xF0, 0xF0, 0xE1, 0xE1, 0xE3, 0xE3, 0xC1,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x07, 0x7F, 0xFC, 0xF8, 0xF8, 0xF8,
  0xF8, 0xF8, 0xF0, 0xE1, 0xE1, 0x43, 0x03, 0x07, 0x07, 0x0F,
  0x87, 0x87, 0xC7, 0xC7, 0xC7, 0xC7, 0x87, 0x87, 0x0F, 0x0F,
  0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFC, 0xFC,
  0xFC, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0xFF, 0xFF,
  0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x0F,
  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x03,
  0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

enum Status {
  BOOT,
  DISPLAY_ERROR,
  RADIO_ERROR,

  BOOT_COMPLETED
};

enum Color {
  NONE = 0x000000,
  PURPLE = 0xA020F0,
  ORANGE = 0xFFA500,
  RED = 0xFF0000,
  BLUE = 0x0000FF,
  FADED_GREEN = 0x001100,
};

struct State {
  int freq;
  byte vol;
  char rds[9];
  Status status;
};

static void updateLedStatus();
static void setStatus(Status);
static inline void freeze();
static inline void setLedColor(Color);
static void drawLogo();
static inline void waitForSerial();
static void fatalError();
static void sendStateToSerial();
static void sendStateToDisplay();
static int readNumberFromSerial();

static Adafruit_NeoPixel pixels(1, PIN_NEOPIXEL);
static QwiicMicroOLED display;
static Si4703_Breakout radio(A3, SDA, SCL);

static State state = {
  1013,
  5,
  {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'},
  BOOT
};


void setup() {
  pixels.begin();

  //Preemptively set error status in case the radio init freezes
  setStatus(RADIO_ERROR);

  radio.powerOn();

  //TEMP Testing
  radio.setVolume(state.vol);
  radio.setChannel(state.freq); // I love jazz

  if (!display.begin()) {
    setStatus(DISPLAY_ERROR);
    freeze();
  }

  drawLogo();
  delay(1000);

  waitForSerial();

  setStatus(BOOT_COMPLETED);

}

void loop() {
  //If serial was disconnect
  if (!Serial) fatalError();

  radio.readRDS(state.rds, 500);
  sendStateToDisplay();
  sendStateToSerial();

  while (Serial.available()) {
    auto command = Serial.read();
    switch (command) {
      case '+':
        state.vol = min(state.vol + 1, 0xf);
        radio.setVolume(state.vol);
        break;

      case '-':
        state.vol = max(state.vol - 1, 0x0);                                                                         
        radio.setVolume(state.vol);
        break;

      case 'u':
        state.freq = radio.seekUp();
        break;

      case 'd':
        state.freq = radio.seekDown();
        break;

      case 's': {
          int newFreq = readNumberFromSerial();
          if (875 <= newFreq && newFreq <= 1080) {
            radio.setChannel(newFreq);
            state.freq = newFreq;
          }

          break;
        }

      case 'v': {
          int newVol = readNumberFromSerial();
          if (0 <= newVol <= 15) {
            state.vol = newVol;
            radio.setVolume(state.vol);
          }
          break;
        }

        //default:
        // Do nothing, arduino doesn't block read and returns -1
    }
  }
}

void freeze() {
  do {} while (true);
}

void setStatus(Status stat) {
  state.status = stat;
  updateLedStatus();
}

void setLedColor(Color color) {
  auto red = (color >> 16) & 0xFF;
  auto green = (color >> 8) & 0xFF;
  auto blue = (color & 0xFF);
  pixels.setPixelColor(0, pixels.Color(red, green, blue));
  pixels.show();
}

void updateLedStatus() {
  switch (state.status) {
    case RADIO_ERROR:
      setLedColor(Color::ORANGE);
      break;

    case DISPLAY_ERROR:
      setLedColor(Color::PURPLE);
      break;

    case BOOT_COMPLETED:
      setLedColor(Color::FADED_GREEN);
      break;

    default:
      setLedColor(Color::NONE);
  }
}

void waitForSerial() {
  Serial.begin(115200);
  while (!Serial) {
    setLedColor(Color::RED);
    delay(500);
    setLedColor(Color::NONE);
    delay(500);
  }
}

void drawLogo() {
  display.erase();
  display.bitmap(0, 0, droidLogo, 64, 48);
  display.display();
}

void sendStateToDisplay() {
  char stationBuffer[25];
  sprintf(stationBuffer, "%02d.%01dMHz", state.freq / 10, state.freq % 10);
  String stationString(stationBuffer); //Sparkfun requires `String`. Not sure how much it is supported in Arduino
  int x0 = (display.getWidth() - QW_FONT_5X7.width * stationString.length()) / 2;
  int y0 = (display.getHeight() - QW_FONT_5X7.height) / 2;
  display.erase();
  display.text(x0, y0, stationString, 1);
  display.rectangleFill(0, 0, (1 + state.vol) * 4, 4, 1);
  display.text(0, display.getHeight() - QW_FONT_5X7.height, state.rds, 1);
  display.display();
}

void fatalError() {
  // Display sick icon
  display.erase();
  display.bitmap(0, 0, errorIcon, 64, 48);
  display.display();

  //Po Po lights !!!
  while (true) {
    setLedColor(Color::RED);
    delay(500);
    setLedColor(Color::BLUE);
    delay(500);
  }
}

void sendStateToSerial() {
  char freqBuffer[5];
  sprintf(freqBuffer, "%04d", state.freq);
  Serial.print(freqBuffer);
  Serial.print(" ");
  Serial.print(state.vol, HEX);
  Serial.print(" ");
  Serial.println(state.rds);
}

int readNumberFromSerial() {
  int num = 0;
  while (isDigit(Serial.peek())) {
    num = num * 10 + (Serial.read() - '0');
  }
  return num;
}
